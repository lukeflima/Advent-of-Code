let read_file filename =
  let ic = open_in filename in
  let rec read_lines acc =
    try
      let line = input_line ic in
      match acc with
      | "" -> read_lines line
      | _ -> read_lines (acc ^ "\n" ^ line)
    with End_of_file ->
      close_in ic;
      acc
  in
  read_lines ""


module G = Graph.Persistent.Graph.Concrete(String)

let parse_node s =
  let parts = String.split_on_char ':' s |> List.map String.trim in
  let name = List.hd parts in
  let connections = List.nth parts 1 |> String.split_on_char ' ' in
  name, connections

(* all the min edge cut code was generated by ChatGPT *)

let get_cut_edges (g : G.t) part1 part2 =
  let set2 = Hashtbl.create (List.length part2) in
  List.iter (fun v -> Hashtbl.add set2 v ()) part2;
  let edges = ref [] in
  List.iter (fun v ->
    G.iter_succ (fun w ->
      if Hashtbl.mem set2 w then
        if G.V.compare v w < 0 then
          edges := (v, w) :: !edges
    ) g v
  ) part1;
  !edges

(*
  stoer_wagner_min_cut implements the global minimum cut algorithm.
  It returns a tuple: (min_cut_weight, (partition1, partition2), list_of_cut_edges)

  Parameters:
  - g: an undirected graph built with OCamlGraph (vertices of type Vertex.t)
  - weight: a function (u v -> int) returning the weight between u and v.
            For an unweighted graph use: (fun _ _ -> 1)

  In addition to the weight matrix, we maintain an array "clusters" such that
  clusters.(i) is the list of original vertices merged into the vertex corresponding
  to index i. When a candidate cut is found in a phase, the partition is defined as:
    - one side: the cluster corresponding to the last added vertex,
    - the other side: the union of all the remaining clusters.
*)
let stoer_wagner_min_cut (g : G.t) =
  
  let weight _ _  = 1 in
  (* List all vertices in the graph *)
  let vertices = G.fold_vertex (fun v acc -> v :: acc) g [] in
  let n = List.length vertices in

  (* Map each vertex to a unique index *)
  let index_of = Hashtbl.create n in
  let vertices_full = Array.of_list vertices in
  Array.iteri (fun i v -> Hashtbl.add index_of v i) vertices_full;

  (* Build the symmetric weight matrix (n x n) *)
  let mat = Array.make_matrix n n 0 in
  List.iter (fun u ->
    let i = Hashtbl.find index_of u in
    G.iter_succ (fun v ->
      let j = Hashtbl.find index_of v in
      if i < j then begin
        let w = weight u v in
        mat.(i).(j) <- w;
        mat.(j).(i) <- w;
      end
    ) g u
  ) vertices;

  (* active: indices of vertices still active (not yet merged) *)
  let active = Array.init n (fun i -> i) in
  let current_n = ref n in

  (* clusters: for each index, maintain the list of original vertices merged into it *)
  let clusters = Array.init n (fun i -> [vertices_full.(i)]) in

  (* best_cut and best_partition record the best candidate found so far *)
  let best_cut = ref max_int in
  let best_partition = ref ([], []) in

  (* Each phase reduces the number of active vertices by one *)
  for _phase = 1 to n - 1 do
    let m = !current_n in
    let added = Array.make m false in
    let weights_local = Array.make m 0 in

    added.(0) <- true;
    let prev = ref 0 in
    for i = 1 to m - 1 do
      weights_local.(i) <- mat.(active.(0)).(active.(i))
    done;
    let last = ref 0 in

    (* Add vertices one by one until all are added *)
    for i = 1 to m - 1 do
      let next = ref (-1) in
      for j = 0 to m - 1 do
        if not added.(j) then
          if !next = -1 || weights_local.(j) > weights_local.(!next) then
            next := j
      done;
      last := !prev;
      prev := !next;
      added.(!next) <- true;
      if i = m - 1 then begin
        (* The candidate cut of this phase is defined by weights_local.( !next ) *)
        if weights_local.(!next) < !best_cut then begin
          best_cut := weights_local.(!next);
          (* Partition: one part is the cluster of the last added vertex,
             the other is the union of clusters of all remaining active vertices *)
          let part1 = clusters.(active.(!next)) in
          let part2 =
            let acc = ref [] in
            for j = 0 to m - 1 do
              if j <> !next then
                acc := List.rev_append (clusters.(active.(j))) !acc
            done;
            !acc
          in
          best_partition := (part1, part2)
        end;
        (* Merge the last two vertices (active[!prev] and active[!next]) *)
        let s = active.(!last) in
        let t = active.(!next) in
        for j = 0 to m - 1 do
          let idx = active.(j) in
          mat.(s).(idx) <- mat.(s).(idx) + mat.(t).(idx);
          mat.(idx).(s) <- mat.(s).(idx)
        done;
        (* Merge clusters: add the vertices of t into s *)
        clusters.(s) <- clusters.(s) @ clusters.(t);
        (* Remove t from active by replacing it with the last element *)
        active.(!next) <- active.(m - 1);
        current_n := m - 1;
      end else begin
        for j = 0 to m - 1 do
          if not added.(j) then
            weights_local.(j) <- weights_local.(j) + mat.(active.(!next)).(active.(j))
        done;
      end
    done
  done;
  
  (* Recover the best partition and compute the cut edges from the original graph *)
  let (part1, part2) = !best_partition in
  let cut_edges = get_cut_edges g part1 part2 in
  (!best_cut, (part1, part2), cut_edges)

let part1 input = 
  let nodes = String.split_on_char '\n' input |> List.map parse_node in
  let g = List.fold_left (
    fun g (name, cons) -> List.fold_left (
      fun g n -> G.add_edge (G.add_edge g name n) n name
    ) g cons
  ) G.empty nodes
  in
  (* let vertexes = G.fold_vertex (fun s a -> s :: a) g [] in *)
  let (_, (p1, p2), _) = stoer_wagner_min_cut g in
  List.fold_left (fun acc l -> acc * List.length l) 1 [p1; p2] |> Int.to_string


(* let input = "sample.txt" *)
let input = "input.txt"

let () =
  let input = read_file input |> String.trim in
  print_string "Part 1: "; 
  print_endline (part1 input);
  